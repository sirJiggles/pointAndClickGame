// javascript-astar 0.2.0
// http://github.com/bgrins/javascript-astar
// Freely distributable under the MIT License.
// Implements the astar search algorithm in javascript using a Binary Heap.
// Includes Binary Heap (with modifications) from Marijn Haverbeke.
// http://eloquentjavascript.net/appendix2.html

(function(definition) {
    if(typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = definition();
    } else if(typeof define === 'function' && define.amd) {
        define([], definition);
    } else {
        var exports = definition();
        window.astar = exports.astar;
        window.Graph = exports.Graph;
    }
})(function() {

var astar = {
    init: function(grid) {
        for(var x = 0, xl = grid.length; x < xl; x++) {
            for(var y = 0, yl = grid[x].length; y < yl; y++) {
                var node = grid[x][y];
                node.f = 0;
                node.g = 0;
                node.h = 0;
                node.cost = node.type;
                node.visited = false;
                node.closed = false;
                node.parent = null;
            }
        }
    },
    heap: function() {
        return new BinaryHeap(function(node) {
            return node.f;
        });
    },

    // astar.search
    // supported options:
    // {
    //   heuristic: heuristic function to use
    //   diagonal: boolean specifying whether diagonal moves are allowed
    //   closest: boolean specifying whether to return closest node if
    //            target is unreachable
    // }
    search: function(grid, start, end, options) {
        astar.init(grid);

        options = options || {};
        var heuristic = options.heuristic || astar.manhattan;
        var diagonal = !!options.diagonal;
        var closest = options.closest || false;

        var openHeap = astar.heap();

        // set the start node to be the closest if required
        var closestNode = start;

        start.h = heuristic(start.pos, end.pos);

        function pathTo(node){
            var curr = node;
            var path = [];
            while(curr.parent) {
                path.push(curr);
                curr = curr.parent;
            }
            return path.reverse();
        }


        openHeap.push(start);

        while(openHeap.size() > 0) {

            // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.
            var currentNode = openHeap.pop();

            // End case -- result has been found, return the traced path.
            if(currentNode === end) {
                return pathTo(currentNode);
            }

            // Normal case -- move currentNode from open to closed, process each of its neighbors.
            currentNode.closed = true;

            // Find all neighbors for the current node. Optionally find diagonal neighbors as well (false by default).
            var neighbors = astar.neighbors(grid, currentNode, diagonal);

            for(var i=0, il = neighbors.length; i < il; i++) {
                var neighbor = neighbors[i];

                if(neighbor.closed || neighbor.isWall()) {
                    // Not a valid node to process, skip to next neighbor.
                    continue;
                }

                // The g score is the shortest distance from start to current node.
                // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.
                var gScore = currentNode.g + neighbor.cost;
                var beenVisited = neighbor.visited;

                if(!beenVisited || gScore < neighbor.g) {

                    // Found an optimal (so far) path to this node.  Take score for node to see how good it is.
                    neighbor.visited = true;
                    neighbor.parent = currentNode;
                    neighbor.h = neighbor.h || heuristic(neighbor.pos, end.pos);
                    neighbor.g = gScore;
                    neighbor.f = neighbor.g + neighbor.h;

                    if (closest) {
                        // If the neighbour is closer than the current closestNode or if it's equally close but has
                        // a cheaper path than the current closest node then it becomes the closest node
                        if (neighbor.h < closestNode.h || (neighbor.h === closestNode.h && neighbor.g < closestNode.g)) {
                            closestNode = neighbor;
                        }
                    }



                    if (!beenVisited) {
                        // Pushing to heap will put it in proper place based on the 'f' value.
                        openHeap.push(neighbor);
                    }
                    else {
                        // Already seen the node, but since it has been rescored we need to reorder it in the heap
                        openHeap.rescoreElement(neighbor);
                    }
                }
            }
        }

        if (closest) {
            return pathTo(closestNode);
        }

        // No result was found - empty array signifies failure to find path.
        return [];
    },
    manhattan: function(pos0, pos1) {
        // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html

        var d1 = Math.abs (pos1.x - pos0.x);
        var d2 = Math.abs (pos1.y - pos0.y);
        return d1 + d2;
    },
    diagonal: function(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs (pos1.x - pos0.x);
        var d2 = Math.abs (pos1.y - pos0.y);
        return (D * (d1 + d2)) + ((D2 - (2 * D)) * Math.min(d1, d2));
    },
    neighbors: function(grid, node, diagonals) {
        var ret = [];
        var x = node.x;
        var y = node.y;

        // West
        if(grid[x-1] && grid[x-1][y]) {
            ret.push(grid[x-1][y]);
        }

        // East
        if(grid[x+1] && grid[x+1][y]) {
            ret.push(grid[x+1][y]);
        }

        // South
        if(grid[x] && grid[x][y-1]) {
            ret.push(grid[x][y-1]);
        }

        // North
        if(grid[x] && grid[x][y+1]) {
            ret.push(grid[x][y+1]);
        }

        if (diagonals) {

            // Southwest
            if(grid[x-1] && grid[x-1][y-1]) {
                ret.push(grid[x-1][y-1]);
            }

            // Southeast
            if(grid[x+1] && grid[x+1][y-1]) {
                ret.push(grid[x+1][y-1]);
            }

            // Northwest
            if(grid[x-1] && grid[x-1][y+1]) {
                ret.push(grid[x-1][y+1]);
            }

            // Northeast
            if(grid[x+1] && grid[x+1][y+1]) {
                ret.push(grid[x+1][y+1]);
            }

        }

        return ret;
    }
};

function Graph(grid) {
    var nodes = [];

    for (var x = 0; x < grid.length; x++) {
        nodes[x] = [];

        for (var y = 0, row = grid[x]; y < row.length; y++) {
            nodes[x][y] = new GraphNode(x, y, row[y]);
        }
    }

    this.input = grid;
    this.nodes = nodes;
}

Graph.prototype.toString = function() {
    var graphString = "\n";
    var nodes = this.nodes;
    var rowDebug, row, y, l;
    for (var x = 0, len = nodes.length; x < len; x++) {
        rowDebug = "";
        row = nodes[x];
        for (y = 0, l = row.length; y < l; y++) {
            rowDebug += row[y].type + " ";
        }
        graphString = graphString + rowDebug + "\n";
    }
    return graphString;
};

function GraphNode(x, y, type) {
    this.data = { };
    this.x = x;
    this.y = y;
    this.pos = {
        x: x,
        y: y
    };
    this.type = type;
}

GraphNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
};

GraphNode.prototype.isWall = function() {
    return this.type === 0;
};

function BinaryHeap(scoreFunction){
    this.content = [];
    this.scoreFunction = scoreFunction;
}

BinaryHeap.prototype = {
    push: function(element) {
        // Add the new element to the end of the array.
        this.content.push(element);

        // Allow it to sink down.
        this.sinkDown(this.content.length - 1);
    },
    pop: function() {
        // Store the first element so we can return it later.
        var result = this.content[0];
        // Get the element at the end of the array.
        var end = this.content.pop();
        // If there are any elements left, put the end element at the
        // start, and let it bubble up.
        if (this.content.length > 0) {
            this.content[0] = end;
            this.bubbleUp(0);
        }
        return result;
    },
    remove: function(node) {
        var i = this.content.indexOf(node);

        // When it is found, the process seen in 'pop' is repeated
        // to fill up the hole.
        var end = this.content.pop();

        if (i !== this.content.length - 1) {
            this.content[i] = end;

            if (this.scoreFunction(end) < this.scoreFunction(node)) {
                this.sinkDown(i);
            }
            else {
                this.bubbleUp(i);
            }
        }
    },
    size: function() {
        return this.content.length;
    },
    rescoreElement: function(node) {
        this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
        // Fetch the element that has to be sunk.
        var element = this.content[n];

        // When at 0, an element can not sink any further.
        while (n > 0) {

            // Compute the parent element's index, and fetch it.
            var parentN = ((n + 1) >> 1) - 1,
                parent = this.content[parentN];
            // Swap the elements if the parent is greater.
            if (this.scoreFunction(element) < this.scoreFunction(parent)) {
                this.content[parentN] = element;
                this.content[n] = parent;
                // Update 'n' to continue at the new position.
                n = parentN;
            }

            // Found a parent that is less, no need to sink any further.
            else {
                break;
            }
        }
    },
    bubbleUp: function(n) {
        // Look up the target element and its score.
        var length = this.content.length,
            element = this.content[n],
            elemScore = this.scoreFunction(element);

        while(true) {
            // Compute the indices of the child elements.
            var child2N = (n + 1) << 1, child1N = child2N - 1;
            // This is used to store the new position of the element,
            // if any.
            var swap = null;
            var child1Score;
            // If the first child exists (is inside the array)...
            if (child1N < length) {
                // Look it up and compute its score.
                var child1 = this.content[child1N];
                child1Score = this.scoreFunction(child1);

                // If the score is less than our element's, we need to swap.
                if (child1Score < elemScore){
                    swap = child1N;
                }
            }

            // Do the same checks for the other child.
            if (child2N < length) {
                var child2 = this.content[child2N],
                    child2Score = this.scoreFunction(child2);
                if (child2Score < (swap === null ? elemScore : child1Score)) {
                    swap = child2N;
                }
            }

            // If the element needs to be moved, swap it, and continue.
            if (swap !== null) {
                this.content[n] = this.content[swap];
                this.content[swap] = element;
                n = swap;
            }

            // Otherwise, we are done.
            else {
                break;
            }
        }
    }
};

return {
    astar: astar,
    Graph: Graph
};

});
/* This is the main container for the game, should be the only real global var */

var core = {

	// set all the properties of the core
	canvases		: 	[
							document.getElementById('sprites'),
							document.getElementById('graph'),
							document.getElementById('debugLayer')
						],
	interval		: 	1000 / 60,
    lastTime		: 	(new Date()).getTime(),
    currentTime		: 	0,
    delta			: 	0,
    state 	 		: 	{
			    			sprites 	: [],
			    			sounds 		: [],
			    			unlocked 	: [],
			    			room 		: null	
						},
    resizeTimer 	: 	null,
    debugMode 		: 	false,
    currentChar		: 	null,
    graphWidthMagnifier: null,
    graphHeightMagnifier: null,
    playSounds		: 	false,
    graphSize		: 	10,
    width 			: 	$('#game-wrapper').innerWidth(),
    height 			: 	$('#game-wrapper').innerHeight(),
    widthToHeight	:   4 / 3,

	// init function
	init: function(){

		// init the math utils
		core.maths = new core.MathUtils();

		// start the game
		core.play();

		// for now spoof the authentication on the rooms
		core.state.unlocked.push([0,1]);

		// set the scene sizes up
		core.resizeWindowCallback();

		// init room one level one
		core.state.room = new core.Room();
		core.state.room.prepareRoom(0,0,[1,8]);

	},

	// update function this is called each frame
	update: function(dt){

		if(core.currentChar){
			core.currentChar.update(dt);
		}
		
	},

	pause: function(){
		requestAnimFrame = null;
	},

	// game loop function
	play: function(){

		// shim layer with setTimeout fallback
		window.requestAnimFrame = (function(){
		  return  window.requestAnimationFrame       ||
		          window.webkitRequestAnimationFrame ||
		          window.mozRequestAnimationFrame    ||
		          function(callback){
		            window.setTimeout(callback, core.interval);
		          };
		})();

		(function animloop(){
			
			core.currentTime = (new Date()).getTime();
    		core.delta = (core.currentTime - core.lastTime);

			// if at least 1 frame has passed in time (1000/fps)
    		if(core.delta > core.interval) {

				// step the game
				core.update(core.delta);

    			// set the last time
				core.lastTime = core.currentTime - (core.delta % core.interval);
			}

			// call this again on animation frame
			requestAnimFrame(animloop);

		})();
	}, // end the game loop

	// simple debuging helper
	debug: function(msg, lvl){
		console.log('================== DEBUG MSG ===============');
		console.log(msg);
		if(typeof lvl !== 'undefined'){
			console.log(' WARNING LVL: '+lvl);
		}
		console.log('================= END DEBUG ================');
	},

	// handle any window resize here
	resizeWindowCallback: function(){

		var previousWidth = core.width,
			previousHeight = core.height,
			wrapper = $('#game-wrapper'),
			inner = $('#game-inner');

		core.width =  $(wrapper).innerWidth();
		core.height = $(wrapper).innerHeight();

		var newWidthToHeight = core.width / core.height;
		if(newWidthToHeight > core.widthToHeight){
			core.width = core.height * core.widthToHeight;
		}else{
			core.height = core.width / core.widthToHeight;
		}

		$(inner).css({
			'width': core.width,
			'height': core.height,
			'margin-top':-core.height / 2,
			'margin-left':-core.width / 2
		});

		$('.inventory').css({
			'width': core.width,
			'margin-left':-core.width / 2
		});

		core.xRatio = core.width / previousWidth;
		core.yRatio = core.height / previousHeight;

		core.updateSprites(true);

		core.resizeCanvs();

		if(core.debugMode){
			core.updateDebug();
		}
    },

    // a debug function only for debug mode redraw updates
    updateDebug: function(){
    	// show the graph
		var ctx = core.canvases[1].getContext('2d');
		//clear the screen first
		ctx.clearRect(0,0,core.width,core.height);
		if(core.currentChar){
			for(var i = 0; i < core.currentChar.graph.input.length; i++){
				for(var j = 0; j < core.currentChar.graph.input[i].length; j++){
					ctx.beginPath();
					ctx.fillStyle = (core.currentChar.graph.input[i][j] == 1) ? 'rgba(35,176,204,0.5)' : 'rgba(240,86,94,0.5)';
					ctx.rect( (j * core.graphWidthMagnifier),(i * core.graphHeightMagnifier),core.graphWidthMagnifier,core.graphHeightMagnifier);
					ctx.fill();
				}
			}
		}
    },

    updateSprites: function(locationAlso){
   
   		// update the location, speed and the size of the sprites
    	for(var i = 0; i < core.state.sprites.length; i ++){
    		var sprite = core.state.sprites[i];
    		sprite.moving = false;
    		if(typeof sprite.location !== 'undefined' && locationAlso){
    			sprite.location.x *= core.xRatio;
    			sprite.location.y *= core.yRatio;
    		}
    		// set the height to be the same as width to maintain the aspect ratio
    		sprite.outputHeight *= core.xRatio;
    		sprite.outputWidth *= core.xRatio;
    		sprite.topSpeed *= core.xRatio;
    		sprite.clear();
    	}

    },

    clearScreen: function(){
    	for(var i = 0; i < core.state.sprites.length; i ++){
    		core.state.sprites[i].clear();
    	}
    },

    resizeCanvs: function(){
    	// resize all of the canvases on the screen to be the same as the window or 'core'
    	for(var i = 0; i < core.canvases.length; i ++){
    		core.canvases[i].width = core.width;
    		core.canvases[i].height = core.height;
    	}

		// work out based on the width and the height of the window what the ratio of widths and heights for the graph is
		core.graphWidthMagnifier = core.width / core.graphSize;
		core.graphHeightMagnifier = core.height / core.graphSize;
    },

    playSound: function(index, loop){
    	if(!core.playSounds){ return; }
    	core.state.sounds[index].play();
		if(loop){
    		core.state.sounds[index].loop = true;
    	}
    	
    },
    stopSound:  function(index){
    	core.state.sounds[index].pause();	
    },
    clearSounds: function(){
    	for(var i = 0; i < core.state.sounds.length; i++){
    		core.state.sounds[i].pause();
    	}
    	// reset the array
    	core.state.sounds = [];
    },

    // sanity check utils function
    sanityCheck : function(vars){
    	for(var i = 0; i < vars.length; i ++){
    		if(typeof vars[i] === 'undefined'){
    			return false;
    		}
    	}
    	return true;
    }

} // end the core
/* Vector 2d class for common vector operations */

core.Vector2D = function(x, y){

	// can also create a new vector from another co-ords
	if(typeof x === 'object'){
		this.x = x.x;
		this.y = x.y;
	}else{
		this.x = (typeof x !== 'undefined') ? x : 0;
		this.y = (typeof y !== 'undefined') ? y : 0;
	}

	return this;
}

// addition
core.Vector2D.prototype.add = function(v){
	this.x = this.x + v.x,
	this.y = this.y + v.y;

	return this;
}

// subtraction
core.Vector2D.prototype.sub = function(v){
	this.x = this.x - v.x,
	this.y = this.y - v.y;

	return this;
}

// multiplication (scale by number)
core.Vector2D.prototype.mult = function(n){
	this.x = this.x * n;
	this.y = this.y * n;

	return this;
}

// magnitude using Pythagorean theorem (used to get the length of a vector)
core.Vector2D.prototype.mag = function(){
	return(Math.sqrt( (this.x * this.x) + (this.y * this.y) ) );
}

// scale with division
core.Vector2D.prototype.div = function(n){
	this.x = this.x / n,
	this.y = this.y / n;

	return this;
}

// normalize vector
core.Vector2D.prototype.normalize = function(){
	// as an example 
	var m = this.mag();
	if(m != 0){
		this.div(m);
	}
}

// dot product (common use to find angle between two vectors)
core.Vector2D.prototype.dot = function(v){
	return ( (this.x * v.x) + (this.y * v.y));
}

// distance from this to another vector
core.Vector2D.prototype.dist = function(v){

	return Math.sqrt(  
				Math.pow((this.x - v.x), 2) + 
				Math.pow((this.y - v.y), 2)
			);
}
/* handy math functions */
core.MathUtils = function(){
	
	this.debugDot = new core.DebugDot({color:'blue'});
}

// Get the angle between two vectors */
core.MathUtils.prototype.angleBetween = function(v1, v2){
	if(typeof v1 !== 'object' && typeof v2 !== 'object'){
		core.debug('call to angle between with incorrect types', 'Warning');
		return false;
	}

	var dot = v1.dot(v2);
	var theta = Math.acos(dot / (v1.mag() * v2.mag()));
	return theta;
}

// get the normal point between start and end of path for a position vector (scalar projection)
core.MathUtils.prototype.getNormalPoint = function(path, predictedLoc){

	// vector from the start of the line to the predicted location
	var a = new core.Vector2D(predictedLoc);
	a.sub(path.start);

	// vector from start to end of line segment
	var b = new core.Vector2D(path.end);
	b.sub(path.start);

	b.normalize();
	// A.B = ||A|| * 1 * cos(theta)
	b.mult(a.dot(b));
	
	var normalPoint = new core.Vector2D(b);
	normalPoint.add(path.start);

	if(core.debugMode){
		this.debugDot.draw(normalPoint);
	}

	return normalPoint;
}

// function to check if vector values are about the same value :D
core.MathUtils.prototype.aboutTheSame = function(va, vb, factor){

	var testX = false,
		testY = false;

	if( Math.abs(va.x - vb.x) < factor){
		testX = true;
	}
	if( Math.abs(va.y - vb.y) < factor){
		testY = true;
	}

	var result = (testX && testY) ? true : false;
	return result;
}

core.MathUtils.prototype.getMiddlePoint = function(va, vb){
	var mid = new core.Vector2D();
	mid.x = (va.x + vb.x) / 2;
	mid.y = (va.y + vb.y) / 2;
	return mid;
}
// Class to handle any graphs that may be attached to a sprite
core.GraphManager = function(){
	
	// this is where we will store our path being processed
	this.graphPath = [];
}

core.GraphManager.prototype.getRoute = function() {
	
	// scale using magnifier to get index in graph array
	var startX = Math.floor(this.location.x / core.graphWidthMagnifier),
		startY = Math.floor(this.location.y / core.graphHeightMagnifier),
		endX = Math.floor(this.target.x / core.graphWidthMagnifier),
		endY = Math.floor(this.target.y / core.graphHeightMagnifier);

	// sanity check a condition that will only happen if you click of the grid
	if(!core.sanityCheck([this.graph.nodes[startY],this.graph.nodes[endY],this.graph.nodes[startY][startY],this.graph.nodes[endY][endX]])){
		core.debug('Unable to find the start locations in the nodes on graphs array', 'WARNING');
		return false;
	}

	var start = this.graph.nodes[startY][startX],
		end = this.graph.nodes[endY][endX];
	// using the super cool a star work out the current path
	this.graphPath = astar.search(this.graph.nodes, start, end);

};

core.GraphManager.prototype.updateGraph = function(){

	// if the target has changed get a new route
	if(this.newTarget){
		this.getRoute();

		if(this.graphPath.length > 0){
			this.setNextTarget();
		}else{
			// prevent the move and reset
			this.moving = false;
			this.target = this.lastLocation;
		}
	}

	
}

core.GraphManager.prototype.setNextTarget = function(){

	if ( !core.sanityCheck([this.graphPath[0]])){
		return false;
	}
	// set the new target to be the center of the next cell on route to final target
	this.target.x = (this.graphPath[0].y * core.graphWidthMagnifier) + core.graphWidthMagnifier / 2;
	this.target.y = (this.graphPath[0].x * core.graphHeightMagnifier) + core.graphHeightMagnifier / 2;
}

// this is called when the mover has reached the target, if its the original target stop moving
// if its not remove it from the list of remaining targets and set the next one up
core.GraphManager.prototype.processTarget = function(){

	// handle if reached target
	if( core.maths.aboutTheSame( this.location, this.originalTarget, core.graphWidthMagnifier / 2) ){
		this.moving = false;
		return false;
	}

	// handle setting of new target
	if( core.maths.aboutTheSame( this.location, this.target, core.graphWidthMagnifier / 2) ){
		this.graphPath.splice(0, 1);
		this.setNextTarget();
	}
}
/* Mover function, for all things that move */

core.Mover = function(){
	
	// introduce physics
	//this.location = new core.Vector2D;
	this.velocity = new core.Vector2D;
	this.acceleration = new core.Vector2D;

	this.moving = false;
	this.target = new core.Vector2D;
	this.originalTarget = new core.Vector2D;
	this.newTarget = false;

	this.debugDot = new core.DebugDot;

	if(this.graph){
		core.GraphManager.call(this);
	}

}

// inherit all the graph manager functions
core.Mover.prototype = Object.create(core.GraphManager.prototype);

core.Mover.prototype.constructor = core.Mover;

// apply force function (accleration gets added the force)
core.Mover.prototype.applyForce = function(force){
	// could introduce mass here :D

	this.acceleration.add(force);
}

/* Seek function to move toward something */
core.Mover.prototype.seek = function(optionalTarget){

	// get the desired location vector
	var desired = new core.Vector2D( (typeof optionalTarget !== 'undefined') ? optionalTarget : this.target);
	desired.sub(this.location);

	// work out how far we are from the target
	var distance = desired.mag();

	// ring around the target
	if(distance < 50){
		// the speed depends on the distance from the target (give some easing)
		desired.mult(0.5);
	}else{
		// continue to move as fast as possible to target
		desired.normalize();
		desired.mult(this.topSpeed);
	}

	if(distance < (core.graphWidthMagnifier / 2) && this.graph){
		this.processTarget();
	}

	var steering = new core.Vector2D(desired);
	steering.sub(this.velocity);

	this.applyForce(steering);
}

/* This function is usually called in some update and will only run if moving */
core.Mover.prototype.move = function(){

	if (!this.moving){
		return false;
	}
	
	if(core.debugMode){
		this.debugDot.clear();
	}

	if(this.graph){
		this.updateGraph();
	}
	
	// move toward target (whatever it may be)
	this.seek();

	// to keep track of what to clear (for sprite sheets);
	if(typeof this.lastLocation !== 'undefined'){

		// work out if moving left or right
		this.flipped = (this.lastLocation.x > this.location.x) ? true : false;
		this.lastLocation = new core.Vector2D(this.location);
	}

	// send forces down the chain
	this.velocity.add(this.acceleration);
	this.location.add(this.velocity);

	// clear acceleration
	this.acceleration.mult(0);

	this.newTarget = false;

}

/* Class for the sprites */

core.SpriteSheet = function(options){

	
	// These are the args we will neeed by default
	if( !core.sanityCheck([options.file, options.frames, options.width, options.height]) ){
		core.debug('Call to sprite sheet with '+options.file+ ' failed, missing required options', 'FATAL');
		return false;
	}

	//  construct al the props of he class
	this.img = new Image();
	this.img.src = options.file;
	this.frames = options.frames;
	this.width = options.width;
	this.height = options.height;
	this.canvas = (typeof options.canvas !== 'undefined') ? options.canvas : core.canvases[0];
	// how fast in ms between each frame
	this.speed = (typeof options.speed !== 'undefined') ? options.speed : 500; 
	this.once =  (typeof options.once !== 'undefined') ? options.once : true
	this.outputHeight = (typeof options.outputHeight !== 'undefined') ? options.outputHeight : options.height;
	this.outputWidth = (typeof options.outputWidth !== 'undefined') ? options.outputWidth : options.width;
	this.ctx = this.canvas.getContext('2d');
	this.currentFrame = 0;
	this.timePassed = 0;
	this.done = true;
	this.topSpeed = (typeof options.topSpeed !== 'undefined') ? options.topSpeed : 10;

	this.location = new core.Vector2D(options.x, options.y);
	this.lastLocation = new core.Vector2D(this.location);
	this.lastRenderLocation = new core.Vector2D(this.location);

	this.flipped = true;

	// a graph to work out the path logic for the sprite (if it needs it)
	this.graph = (typeof options.graph !== 'undefined') ? options.graph : null;

	// call the constructor of the parent class (this gives us location etc)
	core.Mover.call(this);

	return this;

}

// inherits all the mover functions
core.SpriteSheet.prototype = Object.create(core.Mover.prototype);
core.SpriteSheet.prototype.constructor = core.SpriteSheet;

// start and stop functions for sprite sheets
core.SpriteSheet.prototype.start = function(){
	this.done = false;
	return this;
}

core.SpriteSheet.prototype.stop = function(first_argument) {
	this.done = true;
	return this;
};

// update function
core.SpriteSheet.prototype.update = function(dt){

	if(!core.sanityCheck([dt])){return false;}

	if(!this.done){
		// update the index based on the delta
		this.timePassed += Math.floor(dt);

		// if we are due another re-draw
		if(this.timePassed >= this.speed){
			this.render();
			this.timePassed = 0;
		}
	}
}

// render function
core.SpriteSheet.prototype.render = function(){

	this.lastRenderLocation = new core.Vector2D(this.location);

	// clear the space that was last drawn
	this.ctx.clearRect(	this.lastRenderLocation.x - this.outputWidth * 2,
						this.lastRenderLocation.y - this.outputHeight * 2,
						this.outputWidth * 4,
						this.outputHeight * 4);

	var nextFrameLoc = (!this.flipped) ? this.width * this.currentFrame : (this.width * this.currentFrame) + (this.width * (this.frames + 1) );
	// draw the new image
	this.ctx.drawImage( this.img, 
						nextFrameLoc, 
						0, 
						this.width, 
						this.height, 
						this.location.x - (this.outputWidth / 2), 
						this.location.y - (this.outputHeight / 2), 
						this.outputWidth, 
						this.outputHeight);

	// update the current frame
	if(this.currentFrame < this.frames){
		this.currentFrame ++;
	}else{
		// we have completed a full animation sequence 
		this.currentFrame = 0;
		if(this.once){
			this.done = true;
			return false;
		}
	}

	// run any mover code
	this.move();
}

// clear the whole canvas
core.SpriteSheet.prototype.clear = function() {
	this.ctx.clearRect(0,0,core.width,core.height);
};

/* this is just used to show some debug positions */

core.DebugDot = function(options){
	
	this.canvas = core.canvases[2];
	this.ctx = this.canvas.getContext('2d');
	this.radius = 10;

	// if there is some customizations
	if(typeof options !== 'undefined'){
		this.color = (typeof options.color !== 'undefined') ? options.color : 'green';
	}else{
		this.color = 'green';
	}
}

core.DebugDot.prototype.clear = function(){
	this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
}

core.DebugDot.prototype.draw = function(location){
	
	this.ctx.beginPath();
  	this.ctx.arc(location.x, location.y, this.radius, 0, 2 * Math.PI, false);
	this.ctx.fillStyle = this.color;
	this.ctx.fill();
	this.ctx.stroke();
}
core.Room = function(){

}

// get the json data for the room and start to get it all ready
core.Room.prototype.prepareRoom = function(level, room, startPos){

	// sanity checking
	if(!core.sanityCheck([level, room, startPos])){
		core.debug('Tried to init a room without a level and room', 'FATAL');
		return false;
	}

	// do some room clearance first
	this.clear();

	// get the JSON for the room
	$.getJSON('assets/data/levels/'+level+'/'+room+'.json', function(data,status){

		if(status !== 'success'){
			core.debug('Unable to load JSON room data', 'FATAL');
			return false;
		}
		// sanity checking args
		if(!core.sanityCheck([data.music, data.graph, data.doors, data.background])){
			core.debug('Invaild args passed to Room class, core sanity', 'FATAL');
			return false;
		}

		// set up the music
		var bgMusic = new Audio('assets/sounds/'+data.music.file);
		core.state.sounds.push(bgMusic);
		core.playSound(0, data.music.loop);

		// set the bg image
		$('#game-inner').css('background-image', 'url("assets/img/backgrounds/'+data.background+'")');

		// sort out the doors on the room
		var doors = new core.DoorGenerator(data.doors);

		// create the graph for the char
		var graph = new Graph(data.graph);

		// set the initial x and y ratio based on the start screen size
		core.xRatio = core.width / 1024;
		core.yRatio = core.height / 768;

		// check what the main char for this room is and attach the graph to it
		$.getJSON('assets/data/chars.json', function(charData, charStatus){
			if(charStatus !== 'success'){ 
				core.debug('Unable to load the chars file for the room', 'FATAL');
				return false;
			}
			if(!core.sanityCheck([charData[data.char]])){
				core.debug('Could not set up char, sanity chck fail in json read', 'FATAL');
				return false;
			}

			var charOptions = charData[data.char];
			charOptions.graph = graph;

			// set the location to be the grid pos passed in
			charOptions.x = (core.graphWidthMagnifier * startPos[0]) + (core.graphWidthMagnifier / 2);
			charOptions.y = (core.graphHeightMagnifier * startPos[1]) + (core.graphWidthMagnifier / 2);

			var mainChar = new core.SpriteSheet(charOptions).start();

			core.state.sprites.push(mainChar);
			core.currentChar = mainChar;

			// set the sprite ratio
			core.updateSprites(false);

			if(core.debugMode){
				core.updateDebug();
			}
		});
	});
};

core.Room.prototype.clear = function() {
	// remove all old sprites
	core.state.sprites = [];
	// unload sounds
	core.clearSounds();
	// remove old doors
	$('.door').remove();

};
core.DoorGenerator = function(doors){

    if(!core.sanityCheck([doors])){
        core.debug('Unable to insert doors when loading level, do not have all the constructor args', 'FATAL');
        return false;
    }

    this.doors = doors;
    this.insertDoors();
};

core.DoorGenerator.prototype.insertDoors = function(){
    for(var i = 0; i < this.doors.length; i++){
        // generate some dom content for the door
        var dom = '<a href="#" class="door down-'+this.doors[i].location[1]+' accross-'+this.doors[i].location[0]+'" data-level="'+this.doors[i].level+'" data-room="'+this.doors[i].room+'" data-start-x="'+this.doors[i].start[0]+'" data-start-y="'+this.doors[i].start[1]+'"></a>';
        // add it to the body
        $('#game-inner').append(dom);
    };

    // add the click events for all the doors
    $('.door').click(function(evt){
        evt.preventDefault();

        var requestedLvl = $(this).attr('data-level'),
            requestedRoom = $(this).attr('data-room'),
            startLocation = [$(this).attr('data-start-x'), $(this).attr('data-start-y')];
    
        if(typeof core.state.unlocked[requestedLvl] === 'undefined' || typeof core.state.unlocked[requestedLvl][requestedRoom] === 'undefined'){
            core.debug('Tried to access resource with no unlock state', 'WARNING');
            return false;
        }

        // load the next room
        core.state.room.prepareRoom(requestedLvl, requestedRoom, startLocation);

        return false;
    })
}
/* UI javascript, will sort out later most of this is prototype stuff */



$(window).ready(function(){

	$('.inventory-toggle').click(function(evt){
		evt.preventDefault();
		$('.inventory').toggleClass('open');
		$(this).toggleClass('down');
	});

	var dragSrc = '';

	// draggable tests
	var invItems = document.querySelectorAll('.inventory li a');
	// attach events for draggables
	[].forEach.call(invItems, function(item) {
	  	item.addEventListener('dragstart', Drag.dragStart, false);
		item.addEventListener('dragover', Drag.dragOver, false);
		item.addEventListener('drop', Drag.drop, false);
	});

	//set up the click listener (point & click)
	$('#game-inner').click(function(evt){

		// get the location of the click
		var offset = $(this).offset(); 
		var newX = evt.pageX - offset.left,
			newY = evt.pageY - offset.top;
		// set the current active char to have a new target and be moving toward it
		core.currentChar.target = new core.Vector2D(newX, newY);
		core.currentChar.originalTarget = new core.Vector2D(newX, newY);
		core.currentChar.moving = true;
		core.currentChar.newTarget = true;

	});

	// Pressing esc to bring up the main menu
	$(document).keyup(function(evt) {
  		if (evt.keyCode == 27) {
  			// toggle the main menu popup
  			$('#main-menu').modal('toggle');
  		}
	});
	

});

// interface for dragging
var Drag = {

	dragStart: function(evt){
		evt.dataTransfer.effectAllowed = 'move';
  		evt.dataTransfer.setData('text/plain', this.text);
  		dragSrc = this;
	},
	dragEnd: function(){

	},
	dragOver: function(evt){
		// allows us to drop
		if(evt.preventDefault){
			evt.preventDefault();
		}
		evt.dataTransfer.dropEffect = 'move';
	},
	drop: function(evt){
		if(evt.preventDefault){
			evt.preventDefault();
		}

		// used for combining inv items
		if (dragSrc != this) {
			var data = evt.dataTransfer.getData('text/plain');

			// can combine loop with wire
			if( this.text == 'Loop' && data == 'Wire'){
				$(dragSrc).html('');
				$(this).html('');
				$(this).addClass('icon-key');
			}
	  	}
	  	return false;
  	}
}





/*
 * Main javascript file
 * 
 * require all js files in order using juicer
 * 
 * @depends vendor/a-star.js
 * @depends app/core.js
 * @depends app/math/vector-2d.js
 * @depends app/math/utils.js
 * @depends app/lib/graph-manager.js
 * @depends app/lib/mover.js
 * @depends app/lib/sprite-sheet.js
 * @depends app/lib/debug-dot.js
 * @depends app/lib/room.js
 * @depends app/lib/door-generator.js
 * @depends ui.js
 */

// On ready
$(window).ready(function () {
    // start the madness
    core.init();
});

// On resize
$(window).resize(function(){
    clearTimeout(core.resizeTimer);
    core.resizeTimer = setTimeout(core.resizeWindowCallback, 20);
});

